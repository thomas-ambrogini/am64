<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM64x MCU+ SDK: Booting Tools</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM64x MCU+ SDK
   &#160;<span id="projectnumber">08.05.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('TOOLS_BOOT.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Booting Tools </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md1159">Introduction</a></li>
<li class="level1"><a href="#autotoc_md1160">Important files and folders</a></li>
<li class="level1"><a href="#autotoc_md1161">Out2RPRC</a></li>
<li class="level1"><a href="#autotoc_md1162">Multi-core Image Gen</a></li>
<li class="level1"><a href="#TOOLS_BOOT_SIGNING">Signing Scripts</a></li>
<li class="level1"><a href="#autotoc_md1163">XIP Image Generator Tool</a></li>
<li class="level1"><a href="#UART_BOOTLOADER_PYTHON_SCRIPT">UART Bootloader Python Script</a></li>
<li class="level1"><a href="#LINUX_APPIMAGE_GEN_TOOL">Linux Appimage Generator Tool</a></li>
<li class="level1"><a href="#autotoc_md1164">SoC ID parser Python Script</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_components_tools_tools_boot"></a></p>
<dl class="section note"><dt>Note</dt><dd>To see the exact sequence of steps in which applications and secondary bootloader (SBL) are converted from compiler generated .out files to boot images, see the makefile <code>makefile_ccs_bootimage_gen</code> that is included in every example and secondary bootloader (SBL) CCS project.</dd>
<dd>
If you are using makefile based build, then see the file named <code>makefile</code> in the example folder.</dd></dl>
<h1><a class="anchor" id="autotoc_md1159"></a>
Introduction</h1>
<p>This section describes the various tools that are used to create boot images for all the SDK applications</p>
<h1><a class="anchor" id="autotoc_md1160"></a>
Important files and folders</h1>
<table class="doxtable">
<tr>
<th>Folder/Files </th><th>Description  </th></tr>
<tr>
<td colspan="2" bgcolor="#F0F0F0">${SDK_INSTALL_PATH}/tools/boot/ </td></tr>
<tr>
<td>multicoreImageGen/ </td><td>Tool to combine multiple RPRC into a single binary  </td></tr>
<tr>
<td>out2rprc/ </td><td>Tool to convert compiler generated ELF .out for a CPU to a compact and loadable binary representation, called RPRC.  </td></tr>
<tr>
<td>sbl_prebuilt/ </td><td>Pre-built secondary bootloader (SBL) images and flash configuration files for different supported EVMs, see also <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a>  </td></tr>
<tr>
<td>signing/ </td><td><p class="starttd">Security signing scripts need to create boot images that can be booted by ROM bootloader (RBL) </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>xipGen/ </td><td><p class="starttd">Tool to split a RPRC file generated from <code>out2rprc</code> into two files containing non-XIP and XIP sections. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>uart_bootloader.py </td><td>Python script used to send the SBL and appimage binaries over UART using XMODEM protocol in UART boot mode  </td></tr>
<tr>
<td>uart_uniflash.py </td><td>Python script used to flash SBL and applications to EVM flash using UART. See <a class="el" href="TOOLS_FLASH.html">Flashing Tools</a> for more details.  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md1161"></a>
Out2RPRC</h1>
<ul>
<li>This tool converts the application executable (.out) into custom TI RPRC (.rprc) image - an image loadable by the secondary bootloader (SBL).</li>
<li>This tool strips out the initialized sections from the executable file (*.out) and places them in a compact format that the SBL can understand.</li>
<li>The output RPRC file is typically much smaller than the original executable (*.out) file.</li>
<li>The RPRC files are intermediate files in a format that is consumed by <code>MulticoreImageGen</code> tool that generates the final binary that is flashed (<code>*.appimage</code>)</li>
<li>The RPRC file format contains header to various sections in the executable like section run address, size and a overall header which mentions the number of sections and the start offset to the first section.</li>
<li>The RPRC magic word is <code>0x43525052</code> - which is ASCII equivalent for <code>RPRC</code></li>
<li>Shown below is the file header and section format for RPRC files.</li>
</ul>
<p> <style>div.image img[src="tools_rprc_format.png"]{width:40%}</style> </p><div class="image">
<img src="tools_rprc_format.png" alt=""/>
<div class="caption">
RPRC File Format</div></div>
<ul>
<li>This tool is provided as a minified JS script. To convert the application executable into RPRC image file, it can be used as <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/out2rprc</div>
<div class="line">${NODE} elf2rprc.js {input application executable file (.out)}</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="autotoc_md1162"></a>
Multi-core Image Gen</h1>
<ul>
<li>This tool converts the RPRC files created for each CPU into a single combined multicore application image that can be booted by the secondary bootloader (SBL)</li>
<li>Shown below is the file format for multicore image files.</li>
</ul>
<p> <style>div.image img[src="tools_multicore_format.png"]{width:60%}</style> </p><div class="image">
<img src="tools_multicore_format.png" alt=""/>
<div class="caption">
Multi-core Image File Format</div></div>
<ul>
<li>The number of meta headers present is equal to the number of cores included.</li>
<li>The meta header magic word is <code>0x5254534D</code> - which is ASCII equivalent for <code>MSTR</code></li>
<li>In Windows or Linux, use the following command to convert RPRC images into a multicore <code>.appimage</code> file <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/multicoreImageGen</div>
<div class="line">${NODE} multicoreImageGen.js --devID {DEV_ID} --out {Output image file (.appimage)} {core 1 rprc file}@{core 1 id} [ {core n rprc file}@{core n id} ... ]</div>
</div><!-- fragment --></li>
<li>In case of AM64X, <code>DEV_ID</code> is <code>55</code>.</li>
<li>The various core ID to be used are as below.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">CORE  </th><th class="markdownTableHeadNone">CORE ID   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">r5fss0-0  </td><td class="markdownTableBodyNone">4   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">r5fss0-1  </td><td class="markdownTableBodyNone">5   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">r5fss1-0  </td><td class="markdownTableBodyNone">6   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">r5fss1-1  </td><td class="markdownTableBodyNone">7   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">m4fss0-0  </td><td class="markdownTableBodyNone">14   </td></tr>
</table>
<h1><a class="anchor" id="TOOLS_BOOT_SIGNING"></a>
Signing Scripts</h1>
<ul>
<li>To run these scripts, one needs <code>openssl</code> installed as mentioned here, <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_OPENSSL">OpenSSL</a></li>
<li>Signing scripts are a collection of scripts needed to sign ROM images (image booted by ROM - mostly the SBL) and application images (image booted by the SBL)</li>
<li>The RBL requires the boot image (mostly SBL), to be signed always, even if we are not using secure boot.</li>
<li>Use the following command to sign the SBL image. <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/signing</div>
<div class="line">x509CertificateGen.ps1 -b {BOOTIMAGE_BIN_NAME} -o {BOOTIMAGE_NAME} -c R5 -l {SBL_RUN_ADDRESS} -k {BOOTIMAGE_CERT_KEY} -d DEBUG -j DBG_FULL_ENABLE -m SPLIT_MODE</div>
</div><!-- fragment --></li>
<li>In Windows, use powershell to execute the script file. <div class="fragment"><div class="line">powershell -executionpolicy unrestricted -command x509CertificateGen.ps1</div>
</div><!-- fragment --></li>
<li>We follow a combined boot method for ROM images. Here the ROM Bootloader (RBL) boots the SBL, SYSFW and BOARDCFG together. The boot image would be a binary concatenation of x509 Certificate, SBL, SYSFW, BOARDCFG (and the SYSFW inner certificate in case of HS device) binary blobs. We use a python script to generate this final boot image. This script has a dependency on <code>openssl</code> as mentioned before, so make sure you've installed it. To generate a combined boot image, one can do as below:</li>
<li>For GP devices <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/signing</div>
<div class="line">${PYTHON} rom_image_gen.py --swrv 1 --sbl-bin &lt;path-to-sbl-binary&gt; --sysfw-bin &lt;path-to-sysfw-binary&gt; --boardcfg-blob &lt;path-to-boardcfg-binary-blob&gt; --sbl-loadaddr ${SBL_RUN_ADDRESS} --sysfw-loadaddr ${SYSFW_LOAD_ADDR} --bcfg-loadaddr ${BOARDCFG_LOAD_ADDR} --key ${BOOTIMAGE_CERT_KEY} --rom-image &lt;path-to-output-image&gt;</div>
</div><!-- fragment --></li>
<li>For HS devices, we have to pass the HS SYSFW binaries and also the SYSFW inner certificate to the signing script. <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/signing</div>
<div class="line">${PYTHON} rom_image_gen.py --swrv 1 --sbl-bin &lt;path-to-sbl-binary&gt; --sysfw-bin &lt;path-to-sysfw-binary&gt; --sysfw-inner-cert &lt;path-to-sysfw-inner-cert-binary&gt; --boardcfg-blob &lt;path-to-boardcfg-binary-blob&gt; --sbl-loadaddr ${SBL_RUN_ADDRESS} --sysfw-loadaddr ${SYSFW_LOAD_ADDR} --bcfg-loadaddr ${BOARDCFG_LOAD_ADDR} --key ${BOOTIMAGE_CERT_KEY} --debug DBG_FULL_ENABLE --rom-image &lt;path-to-output-image&gt;</div>
</div><!-- fragment --></li>
<li>By default SBLs provided in SDK are signed with full debug enable since this is needed for development. You can see from <code>--debug</code> switch used above. Once moved to production please remove this switch from the makefile.</li>
<li>For SBL images or examples which is loaded by SBL, we use a different signing script. This is solely because of the x509 certificate template differences between ROM and SYSFW. In GP devices appimages are not signed. The signing happens only in HS devices. The script usage is: <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/signing</div>
<div class="line">$(PYTHON) appimage_x509_cert_gen.py --bin &lt;path-to-the-binary&gt; --authtype 1 --key &lt;signing-key-derived-from-devconfig&gt; --output &lt;output-image-name&gt;</div>
</div><!-- fragment --></li>
<li>In the case of encryption, two extra options are also passed to the script like so: <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/signing</div>
<div class="line">$(PYTHON) appimage_x509_cert_gen.py --bin &lt;path-to-the-binary&gt; --authtype 1 --key &lt;signing-key-derived-from-devconfig&gt; --enc y --enckey &lt;encryption-key-derived-from-devconfig&gt; --output &lt;output-image-name&gt;</div>
</div><!-- fragment --></li>
<li>These scripts are invoked in makefiles, and the image generation happens automatically along with the example build. So mostly these scripts need not be manually run.<ul>
<li>Here,<ul>
<li><code>SBL_RUN_ADDRESS</code> is <code>0x70000000</code></li>
<li>In the case of GP device, <code>BOOTIMAGE_CERT_KEY</code> is <code>rom_degenerateKey.pem</code></li>
<li>In the case of HS device, <code>BOOTIMAGE_CERT_KEY</code> is <code>custMpk_am64x_am243x.pem</code>. For more details about this see <a class="el" href="SECURE_BOOT.html">Enabling Secure Boot</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1163"></a>
XIP Image Generator Tool</h1>
<ul>
<li>This tool, splits a input RPRC application file, into two RPRC files,<ul>
<li>First RPRC file, containing non-XIP sections and the application entry point</li>
<li>Second RPRC file, containing XIP sections. Here, adjacent sections are merged into one section</li>
</ul>
</li>
<li>The final number of sections in both RPRC files taken together can be less than the sections in the input file due to section merging in the XIP RPRC file.</li>
</ul>
<p> <style>div.image img[src="tools_xip_gen.png"]{width:60%}</style> </p><div class="image">
<img src="tools_xip_gen.png" alt=""/>
<div class="caption">
XIP Image Generation Tool flow</div></div>
<ul>
<li>The non-XIP RPRC file should be flashed and booted via SBL as usual</li>
<li>The XIP RPRC file should be flashed via the SDK flash writer, using the command <code>--flash-xip</code>, the flash writer in this case will flash sections at the flash address mentioned in the RPRC section header.</li>
<li>To see the detailed options supported by the tool, run this tool with the option <code>--help</code>. Example, output in Windows is shown below,</li>
</ul>
<div class="fragment"><div class="line">&gt; cd {SDK_INSTALL_PATH}/tools/boot/xipGen</div>
<div class="line">&gt; xipGen.exe</div>
<div class="line"> </div>
<div class="line">  XIP Image Creation Tool  - (c) Texas Instruments 2021, created on Apr 19 2021</div>
<div class="line"> </div>
<div class="line">  Usage: xipGen [options]</div>
<div class="line"> </div>
<div class="line">  Description,</div>
<div class="line">  This tool, splits a input RPRC application file, into two RPRC files,</div>
<div class="line">  - First RPRC file, containing non-XIP sections. The application entry point is assumed</div>
<div class="line">      to be in non-XIP region.</div>
<div class="line">  - Second RPRC file, containing XIP sections. The RPRC entry point is set to 0 and</div>
<div class="line">      adjacent XIP sections are merged</div>
<div class="line"> </div>
<div class="line">  Note, the final number of sections in both RPRC files taken together can be less</div>
<div class="line">  than the sections in the input file due to section merging in the XIP RPRC file.</div>
<div class="line"> </div>
<div class="line">  The non-XIP RPRC file should be flashed and booted via SBL as usual</div>
<div class="line"> </div>
<div class="line">  The XIP RPRC file should be flashed via the SDK flash writer, the flash writer will</div>
<div class="line">  flash sections at the flash address mentioned in the RPRC sections</div>
<div class="line"> </div>
<div class="line">  Options,</div>
<div class="line">  --input, -i : input RPRC file,</div>
<div class="line">  --output, -o : output RPRC file of non-XIP sections,</div>
<div class="line">  --output-xip, -x : output RPRC file of XIP sections,</div>
<div class="line">  --flash-start-addr, -f : XIP flash address space start, specified in hex. If not specified 0x60000000 is used</div>
<div class="line">  --flash-size, -s : XIP flash address space size in units of mega bytes, specified as integer. If not specified 256 MB is used</div>
<div class="line">  --verbose, -v : Verbose prints are enabled during the tool execution</div>
<div class="line">  --help, -h : Shows this help</div>
</div><!-- fragment --><h1><a class="anchor" id="UART_BOOTLOADER_PYTHON_SCRIPT"></a>
UART Bootloader Python Script</h1>
<ul>
<li>This script is used in UART boot mode for sending the SBL and appimage binaries to the EVM via UART using XMODEM protocol</li>
<li>Make sure that python3 and its dependent modules are installed in the host machine as mentioned in <a class="el" href="SDK_DOWNLOAD_PAGE.html#INSTALL_PYTHON3">Python3</a></li>
<li>Booting via UART is slow, but is useful if application loading via CCS or OSPI boot is not an option</li>
<li>Make sure the UART port used for terminal is identified as mentioned in <a class="el" href="EVM_SETUP_PAGE.html#CCS_UART_TERMINAL">Setup UART Terminal</a></li>
<li>Make sure you have the EVM power cable and UART cable connected as shown in <a class="el" href="EVM_SETUP_PAGE.html#EVM_CABLES">Cable Connections</a></li>
<li>To boot applications using this script, <b>POWER OFF the EVM</b></li>
<li>Switch to <a class="el" href="EVM_SETUP_PAGE.html#BOOTMODE_UART">UART BOOT MODE</a>.</li>
<li><b>POWER ON the EVM</b></li>
<li>To confirm that the board is in UART boot mode, open the UART terminal and confirm that you see the character 'C' getting printed on the console every 2-3 seconds.</li>
<li>Now close the terminal. This is important as the script won't be able to function properly if the UART terminal is open.</li>
<li>Open a command prompt and run the below command to send the SBL and application binary to the EVM <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot</div>
<div class="line">python uart_bootloader.py -p COM&lt;x&gt; --bootloader=sbl_prebuilt/{board}/sbl_uart.release.tiimage --file=&lt; path to multicore appimage of application binary &gt;</div>
</div><!-- fragment --></li>
<li>When you execute this, the script first sends the uart bootloader, and then the multicore appimage</li>
<li>After the multicore appimage is successfully parsed, the uart bootloader sends an acknowledgment to the script and waits for 5 seconds before running the application binary</li>
<li>Upon receiving the ack, the script will exit successfully</li>
<li>Connect to the UART terminal within 5 seconds to see logs from the application</li>
<li>Below are the logs of the script after all the files have been sent <div class="fragment"><div class="line">Sending the UART bootloader sbl_prebuilt/{board}/sbl_uart.release.tiimage ...</div>
<div class="line">Sent bootloader sbl_prebuilt/{board}/sbl_uart.release.tiimage of size 243975 bytes in 23.94s.</div>
<div class="line"> </div>
<div class="line">Sending the application ../../examples/drivers/udma/udma_memcpy_polling/{board}/r5fss0-0_nortos/ti-arm-clang/udma_memcpy_polling.release.appimage ...</div>
<div class="line">Sent application ../../examples/drivers/udma/udma_memcpy_polling/{board}/r5fss0-0_nortos/ti-arm-clang/udma_memcpy_polling.release.appimage of size 99580 bytes in 11.74s.</div>
<div class="line">[STATUS] Application load SUCCESS !!!</div>
<div class="line">Connect to UART in 5 seconds to see logs from UART !!!</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="LINUX_APPIMAGE_GEN_TOOL"></a>
Linux Appimage Generator Tool</h1>
<ul>
<li>This tool generates a Linux Appimage by taking the Linux binaries (ATF, OPTEE, SPL) as input and generates a Linux appimage containing the input Linux binaries.</li>
<li>The input file location can be mentioned in the <code>config.mak</code> file located at {SDK_INSTALL_PATH}/tools/boot/linuxAppimageGen<ul>
<li><code>PSDK_LINUX_PREBUILT_IMAGES=/board-support/prebuilt-images</code></li>
</ul>
</li>
<li>The input file names for ATF, OPTEE and SPL can also be mentioned in the <code>config.mak</code> file.<ul>
<li><code>#Input linux binaries</code><br  />
 <code>ATF_BIN_NAME=bl31.bin</code><br  />
 <code>OPTEE_BIN_NAME=bl32.bin</code><br  />
 <code>SPL_BIN_NAME=u-boot-spl.bin-am64xx-evm</code><br  />
</li>
</ul>
</li>
<li>The load address for ATF, OPTEE and SPL need to be mentioned in the <code>config.mak</code> file.<ul>
<li><code>#Linux image load address</code><br  />
 <code>ATF_LOAD_ADDR=0x0701a0000</code><br  />
 <code>OPTEE_LOAD_ADDR=0x9e800000</code><br  />
 <code>SPL_LOAD_ADDR=0x80080000</code><br  />
</li>
</ul>
</li>
<li>The output appimage name can be mentioned in the <code>config.mak</code> file.<ul>
<li><code>#Output appimage name</code><br  />
 <code>LINUX_BOOTIMAGE_NAME=linux.appimage</code><br  />
</li>
</ul>
</li>
<li>Run the makefile at {SDK_INSTALL_PATH}/tools/boot/linuxAppimageGen to generate the Linux appimage<ul>
<li>For Windows <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/linuxAppimageGen</div>
<div class="line">gmake -s all</div>
</div><!-- fragment --></li>
<li>For Linux <div class="fragment"><div class="line">cd ${SDK_INSTALL_PATH}/tools/boot/linuxAppimageGen</div>
<div class="line">make -s all</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>The Linux appimage wil be generated at {SDK_INSTALL_PATH}/tools/boot/linuxAppimageGen after running the makefile</li>
</ul>
<h1><a class="anchor" id="autotoc_md1164"></a>
SoC ID parser Python Script</h1>
<ul>
<li>Boot ROM reports SoC ID on UART console of the device when UART boot mode is selected. It reports on both GP and HS devices and it provides insights into device configuration which would be helpful for debugs.</li>
<li>uart_boot_socid.py is a python based parser to convert the hexadecimal numbers reported by ROM to human readable text, below are the steps involved to use this parser. This will be helpful in debugging the device boot issue. This will also help to see important information about device like device type, prime/non-prime, key count, key revision, MPK hash etc.</li>
<li>Steps to use the parser:</li>
</ul>
<p>1) Copy the soc id reported in UART console to socid.txt (socid.txt)</p>
<p>2) execute</p>
<div class="fragment"><div class="line">$python uart_boot_socid.py socid.txt</div>
</div><!-- fragment --><ul>
<li>Example Output:</li>
</ul>
<p>SoC ID Header Info: <br  />
 <br  />
 NumBlocks : [2] <br  />
 <br  />
 SoC ID Public ROM Info: <br  />
 <br  />
 SubBlockId : 1 <br  />
SubBlockSize : 26 <br  />
DeviceName : am64x <br  />
DeviceType : HSSE <br  />
DMSC ROM Version : [0, 1, 1, 1] <br  />
R5 ROM Version : [0, 1, 1, 1] <br  />
 <br  />
 SoC ID Secure ROM Info: <br  />
 <br  />
 Sec SubBlockId : 2 <br  />
Sec SubBlockSize : 166 <br  />
Sec Prime : 0 <br  />
Sec Key Revision : 1 <br  />
Sec Key Count : 1 <br  />
Sec TI MPK Hash : aa1f8e3095042e5c71ac40ede5b4e8c85fa87e03305ae0ea4f47933e89f4164aeb5a12ae13778f49de0622c1a578e6e747981d8c44a130f89a336a887a7955ee <br  />
Sec Cust MPK Hash : 1f6002b07cd9b0b7c47d9ca8d1aae57b8e8784a12f636b2b760d7d98a18f189760dfd0f23e2b0cb10ec7edc7c6edac3d9bdfefe0eddc3fff7fe9ad875195527d <br  />
Sec Unique ID : fd6e232b89dfc6ea125c2fa09f25f95034e08a54797490c32bf47c64bf4c8f21 <br  />
</p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
